// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: flipper.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PB_CommandStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ok // = 0

  ///*< Unknown error 
  case error // = 1

  ///*< Command can't be decoded successfully - command_id in response may be wrong! 
  case errorDecode // = 2

  ///*< Command succesfully decoded, but not implemented (deprecated or not yet implemented) 
  case errorNotImplemented // = 3

  ///*< Somebody took global lock, so not all commands are available 
  case errorBusy // = 4

  ///*< Not received not_last == 0 
  case errorContinuousCommandInterrupted // = 14

  ///*< not provided (or provided invalid) crucial parameters to perform rpc 
  case errorInvalidParameters // = 15

  ///*< FS not ready 
  case errorStorageNotReady // = 5

  ///*< File/Dir alrady exist 
  case errorStorageExist // = 6

  ///*< File/Dir does not exist 
  case errorStorageNotExist // = 7

  ///*< Invalid API parameter 
  case errorStorageInvalidParameter // = 8

  ///*< Access denied 
  case errorStorageDenied // = 9

  ///*< Invalid name/path 
  case errorStorageInvalidName // = 10

  ///*< Internal error 
  case errorStorageInternal // = 11

  ///*< Functon not implemented 
  case errorStorageNotImplemented // = 12

  ///*< File/Dir already opened 
  case errorStorageAlreadyOpen // = 13
  case UNRECOGNIZED(Int)

  init() {
    self = .ok
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .error
    case 2: self = .errorDecode
    case 3: self = .errorNotImplemented
    case 4: self = .errorBusy
    case 5: self = .errorStorageNotReady
    case 6: self = .errorStorageExist
    case 7: self = .errorStorageNotExist
    case 8: self = .errorStorageInvalidParameter
    case 9: self = .errorStorageDenied
    case 10: self = .errorStorageInvalidName
    case 11: self = .errorStorageInternal
    case 12: self = .errorStorageNotImplemented
    case 13: self = .errorStorageAlreadyOpen
    case 14: self = .errorContinuousCommandInterrupted
    case 15: self = .errorInvalidParameters
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ok: return 0
    case .error: return 1
    case .errorDecode: return 2
    case .errorNotImplemented: return 3
    case .errorBusy: return 4
    case .errorStorageNotReady: return 5
    case .errorStorageExist: return 6
    case .errorStorageNotExist: return 7
    case .errorStorageInvalidParameter: return 8
    case .errorStorageDenied: return 9
    case .errorStorageInvalidName: return 10
    case .errorStorageInternal: return 11
    case .errorStorageNotImplemented: return 12
    case .errorStorageAlreadyOpen: return 13
    case .errorContinuousCommandInterrupted: return 14
    case .errorInvalidParameters: return 15
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PB_CommandStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PB_CommandStatus] = [
    .ok,
    .error,
    .errorDecode,
    .errorNotImplemented,
    .errorBusy,
    .errorContinuousCommandInterrupted,
    .errorInvalidParameters,
    .errorStorageNotReady,
    .errorStorageExist,
    .errorStorageNotExist,
    .errorStorageInvalidParameter,
    .errorStorageDenied,
    .errorStorageInvalidName,
    .errorStorageInternal,
    .errorStorageNotImplemented,
    .errorStorageAlreadyOpen,
  ]
}

#endif  // swift(>=4.2)

/// There are Server commands (e.g. Storage_write), which have no body message
/// in response. But 'oneof' obligate to have at least 1 encoded message
/// in scope. For this needs Empty message is implemented.
struct PB_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PB_Main {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var commandID: UInt32 = 0

  var commandStatus: PB_CommandStatus = .ok

  var notLast: Bool = false

  var content: PB_Main.OneOf_Content? = nil

  var empty: PB_Empty {
    get {
      if case .empty(let v)? = content {return v}
      return PB_Empty()
    }
    set {content = .empty(newValue)}
  }

  var pingRequest: PBStatus_PingRequest {
    get {
      if case .pingRequest(let v)? = content {return v}
      return PBStatus_PingRequest()
    }
    set {content = .pingRequest(newValue)}
  }

  var pingResponse: PBStatus_PingResponse {
    get {
      if case .pingResponse(let v)? = content {return v}
      return PBStatus_PingResponse()
    }
    set {content = .pingResponse(newValue)}
  }

  var storageListRequest: PBStorage_ListRequest {
    get {
      if case .storageListRequest(let v)? = content {return v}
      return PBStorage_ListRequest()
    }
    set {content = .storageListRequest(newValue)}
  }

  var storageListResponse: PBStorage_ListResponse {
    get {
      if case .storageListResponse(let v)? = content {return v}
      return PBStorage_ListResponse()
    }
    set {content = .storageListResponse(newValue)}
  }

  var storageReadRequest: PBStorage_ReadRequest {
    get {
      if case .storageReadRequest(let v)? = content {return v}
      return PBStorage_ReadRequest()
    }
    set {content = .storageReadRequest(newValue)}
  }

  var storageReadResponse: PBStorage_ReadResponse {
    get {
      if case .storageReadResponse(let v)? = content {return v}
      return PBStorage_ReadResponse()
    }
    set {content = .storageReadResponse(newValue)}
  }

  var storageWriteRequest: PBStorage_WriteRequest {
    get {
      if case .storageWriteRequest(let v)? = content {return v}
      return PBStorage_WriteRequest()
    }
    set {content = .storageWriteRequest(newValue)}
  }

  var storageDeleteRequest: PBStorage_DeleteRequest {
    get {
      if case .storageDeleteRequest(let v)? = content {return v}
      return PBStorage_DeleteRequest()
    }
    set {content = .storageDeleteRequest(newValue)}
  }

  var storageMkdirRequest: PBStorage_MkdirRequest {
    get {
      if case .storageMkdirRequest(let v)? = content {return v}
      return PBStorage_MkdirRequest()
    }
    set {content = .storageMkdirRequest(newValue)}
  }

  var storageMd5SumRequest: PBStorage_Md5sumRequest {
    get {
      if case .storageMd5SumRequest(let v)? = content {return v}
      return PBStorage_Md5sumRequest()
    }
    set {content = .storageMd5SumRequest(newValue)}
  }

  var storageMd5SumResponse: PBStorage_Md5sumResponse {
    get {
      if case .storageMd5SumResponse(let v)? = content {return v}
      return PBStorage_Md5sumResponse()
    }
    set {content = .storageMd5SumResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case empty(PB_Empty)
    case pingRequest(PBStatus_PingRequest)
    case pingResponse(PBStatus_PingResponse)
    case storageListRequest(PBStorage_ListRequest)
    case storageListResponse(PBStorage_ListResponse)
    case storageReadRequest(PBStorage_ReadRequest)
    case storageReadResponse(PBStorage_ReadResponse)
    case storageWriteRequest(PBStorage_WriteRequest)
    case storageDeleteRequest(PBStorage_DeleteRequest)
    case storageMkdirRequest(PBStorage_MkdirRequest)
    case storageMd5SumRequest(PBStorage_Md5sumRequest)
    case storageMd5SumResponse(PBStorage_Md5sumResponse)

  #if !swift(>=4.1)
    static func ==(lhs: PB_Main.OneOf_Content, rhs: PB_Main.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pingRequest, .pingRequest): return {
        guard case .pingRequest(let l) = lhs, case .pingRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pingResponse, .pingResponse): return {
        guard case .pingResponse(let l) = lhs, case .pingResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageListRequest, .storageListRequest): return {
        guard case .storageListRequest(let l) = lhs, case .storageListRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageListResponse, .storageListResponse): return {
        guard case .storageListResponse(let l) = lhs, case .storageListResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageReadRequest, .storageReadRequest): return {
        guard case .storageReadRequest(let l) = lhs, case .storageReadRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageReadResponse, .storageReadResponse): return {
        guard case .storageReadResponse(let l) = lhs, case .storageReadResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageWriteRequest, .storageWriteRequest): return {
        guard case .storageWriteRequest(let l) = lhs, case .storageWriteRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageDeleteRequest, .storageDeleteRequest): return {
        guard case .storageDeleteRequest(let l) = lhs, case .storageDeleteRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageMkdirRequest, .storageMkdirRequest): return {
        guard case .storageMkdirRequest(let l) = lhs, case .storageMkdirRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageMd5SumRequest, .storageMd5SumRequest): return {
        guard case .storageMd5SumRequest(let l) = lhs, case .storageMd5SumRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageMd5SumResponse, .storageMd5SumResponse): return {
        guard case .storageMd5SumResponse(let l) = lhs, case .storageMd5SumResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "PB"

extension PB_CommandStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "ERROR"),
    2: .same(proto: "ERROR_DECODE"),
    3: .same(proto: "ERROR_NOT_IMPLEMENTED"),
    4: .same(proto: "ERROR_BUSY"),
    5: .same(proto: "ERROR_STORAGE_NOT_READY"),
    6: .same(proto: "ERROR_STORAGE_EXIST"),
    7: .same(proto: "ERROR_STORAGE_NOT_EXIST"),
    8: .same(proto: "ERROR_STORAGE_INVALID_PARAMETER"),
    9: .same(proto: "ERROR_STORAGE_DENIED"),
    10: .same(proto: "ERROR_STORAGE_INVALID_NAME"),
    11: .same(proto: "ERROR_STORAGE_INTERNAL"),
    12: .same(proto: "ERROR_STORAGE_NOT_IMPLEMENTED"),
    13: .same(proto: "ERROR_STORAGE_ALREADY_OPEN"),
    14: .same(proto: "ERROR_CONTINUOUS_COMMAND_INTERRUPTED"),
    15: .same(proto: "ERROR_INVALID_PARAMETERS"),
  ]
}

extension PB_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_Empty, rhs: PB_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_Main: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Main"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    2: .standard(proto: "command_status"),
    3: .standard(proto: "not_last"),
    4: .same(proto: "empty"),
    5: .standard(proto: "ping_request"),
    6: .standard(proto: "ping_response"),
    7: .standard(proto: "storage_list_request"),
    8: .standard(proto: "storage_list_response"),
    9: .standard(proto: "storage_read_request"),
    10: .standard(proto: "storage_read_response"),
    11: .standard(proto: "storage_write_request"),
    12: .standard(proto: "storage_delete_request"),
    13: .standard(proto: "storage_mkdir_request"),
    14: .standard(proto: "storage_md5sum_request"),
    15: .standard(proto: "storage_md5sum_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.commandID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.commandStatus) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.notLast) }()
      case 4: try {
        var v: PB_Empty?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .empty(v)
        }
      }()
      case 5: try {
        var v: PBStatus_PingRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .pingRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .pingRequest(v)
        }
      }()
      case 6: try {
        var v: PBStatus_PingResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .pingResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .pingResponse(v)
        }
      }()
      case 7: try {
        var v: PBStorage_ListRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageListRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageListRequest(v)
        }
      }()
      case 8: try {
        var v: PBStorage_ListResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageListResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageListResponse(v)
        }
      }()
      case 9: try {
        var v: PBStorage_ReadRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageReadRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageReadRequest(v)
        }
      }()
      case 10: try {
        var v: PBStorage_ReadResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageReadResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageReadResponse(v)
        }
      }()
      case 11: try {
        var v: PBStorage_WriteRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageWriteRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageWriteRequest(v)
        }
      }()
      case 12: try {
        var v: PBStorage_DeleteRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageDeleteRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageDeleteRequest(v)
        }
      }()
      case 13: try {
        var v: PBStorage_MkdirRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageMkdirRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageMkdirRequest(v)
        }
      }()
      case 14: try {
        var v: PBStorage_Md5sumRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageMd5SumRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageMd5SumRequest(v)
        }
      }()
      case 15: try {
        var v: PBStorage_Md5sumResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageMd5SumResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageMd5SumResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.commandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.commandID, fieldNumber: 1)
    }
    if self.commandStatus != .ok {
      try visitor.visitSingularEnumField(value: self.commandStatus, fieldNumber: 2)
    }
    if self.notLast != false {
      try visitor.visitSingularBoolField(value: self.notLast, fieldNumber: 3)
    }
    switch self.content {
    case .empty?: try {
      guard case .empty(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .pingRequest?: try {
      guard case .pingRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .pingResponse?: try {
      guard case .pingResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .storageListRequest?: try {
      guard case .storageListRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .storageListResponse?: try {
      guard case .storageListResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .storageReadRequest?: try {
      guard case .storageReadRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .storageReadResponse?: try {
      guard case .storageReadResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .storageWriteRequest?: try {
      guard case .storageWriteRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .storageDeleteRequest?: try {
      guard case .storageDeleteRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .storageMkdirRequest?: try {
      guard case .storageMkdirRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .storageMd5SumRequest?: try {
      guard case .storageMd5SumRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .storageMd5SumResponse?: try {
      guard case .storageMd5SumResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_Main, rhs: PB_Main) -> Bool {
    if lhs.commandID != rhs.commandID {return false}
    if lhs.commandStatus != rhs.commandStatus {return false}
    if lhs.notLast != rhs.notLast {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
