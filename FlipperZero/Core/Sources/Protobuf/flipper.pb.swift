// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: flipper.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PB_CommandStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ok // = 0
  case error // = 1
  case errorNoSpace // = 2
  case errorNoFile // = 3
  case errorDecode // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .ok
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .error
    case 2: self = .errorNoSpace
    case 3: self = .errorNoFile
    case 4: self = .errorDecode
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ok: return 0
    case .error: return 1
    case .errorNoSpace: return 2
    case .errorNoFile: return 3
    case .errorDecode: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PB_CommandStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PB_CommandStatus] = [
    .ok,
    .error,
    .errorNoSpace,
    .errorNoFile,
    .errorDecode,
  ]
}

#endif  // swift(>=4.2)

struct PB_Dummy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PB_Main {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var commandID: UInt32 = 0

  var commandStatus: PB_CommandStatus = .ok

  var notLast: Bool = false

  var content: PB_Main.OneOf_Content? = nil

  var dummy: PB_Dummy {
    get {
      if case .dummy(let v)? = content {return v}
      return PB_Dummy()
    }
    set {content = .dummy(newValue)}
  }

  var pingRequest: PBStatus_PingRequest {
    get {
      if case .pingRequest(let v)? = content {return v}
      return PBStatus_PingRequest()
    }
    set {content = .pingRequest(newValue)}
  }

  var pingResponse: PBStatus_PingResponse {
    get {
      if case .pingResponse(let v)? = content {return v}
      return PBStatus_PingResponse()
    }
    set {content = .pingResponse(newValue)}
  }

  var storageListRequest: PBStorage_ListRequest {
    get {
      if case .storageListRequest(let v)? = content {return v}
      return PBStorage_ListRequest()
    }
    set {content = .storageListRequest(newValue)}
  }

  var storageListResponse: PBStorage_ListResponse {
    get {
      if case .storageListResponse(let v)? = content {return v}
      return PBStorage_ListResponse()
    }
    set {content = .storageListResponse(newValue)}
  }

  var storageReadRequest: PBStorage_ReadRequest {
    get {
      if case .storageReadRequest(let v)? = content {return v}
      return PBStorage_ReadRequest()
    }
    set {content = .storageReadRequest(newValue)}
  }

  var storageReadResponse: PBStorage_ReadResponse {
    get {
      if case .storageReadResponse(let v)? = content {return v}
      return PBStorage_ReadResponse()
    }
    set {content = .storageReadResponse(newValue)}
  }

  var storageWriteRequest: PBStorage_WriteRequest {
    get {
      if case .storageWriteRequest(let v)? = content {return v}
      return PBStorage_WriteRequest()
    }
    set {content = .storageWriteRequest(newValue)}
  }

  var storageDeleteRequest: PBStorage_DeleteRequest {
    get {
      if case .storageDeleteRequest(let v)? = content {return v}
      return PBStorage_DeleteRequest()
    }
    set {content = .storageDeleteRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case dummy(PB_Dummy)
    case pingRequest(PBStatus_PingRequest)
    case pingResponse(PBStatus_PingResponse)
    case storageListRequest(PBStorage_ListRequest)
    case storageListResponse(PBStorage_ListResponse)
    case storageReadRequest(PBStorage_ReadRequest)
    case storageReadResponse(PBStorage_ReadResponse)
    case storageWriteRequest(PBStorage_WriteRequest)
    case storageDeleteRequest(PBStorage_DeleteRequest)

  #if !swift(>=4.1)
    static func ==(lhs: PB_Main.OneOf_Content, rhs: PB_Main.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dummy, .dummy): return {
        guard case .dummy(let l) = lhs, case .dummy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pingRequest, .pingRequest): return {
        guard case .pingRequest(let l) = lhs, case .pingRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pingResponse, .pingResponse): return {
        guard case .pingResponse(let l) = lhs, case .pingResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageListRequest, .storageListRequest): return {
        guard case .storageListRequest(let l) = lhs, case .storageListRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageListResponse, .storageListResponse): return {
        guard case .storageListResponse(let l) = lhs, case .storageListResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageReadRequest, .storageReadRequest): return {
        guard case .storageReadRequest(let l) = lhs, case .storageReadRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageReadResponse, .storageReadResponse): return {
        guard case .storageReadResponse(let l) = lhs, case .storageReadResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageWriteRequest, .storageWriteRequest): return {
        guard case .storageWriteRequest(let l) = lhs, case .storageWriteRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageDeleteRequest, .storageDeleteRequest): return {
        guard case .storageDeleteRequest(let l) = lhs, case .storageDeleteRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "PB"

extension PB_CommandStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "ERROR"),
    2: .same(proto: "ERROR_NO_SPACE"),
    3: .same(proto: "ERROR_NO_FILE"),
    4: .same(proto: "ERROR_DECODE"),
  ]
}

extension PB_Dummy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Dummy"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_Dummy, rhs: PB_Dummy) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_Main: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Main"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    2: .standard(proto: "command_status"),
    3: .standard(proto: "not_last"),
    12: .same(proto: "dummy"),
    4: .standard(proto: "ping_request"),
    5: .standard(proto: "ping_response"),
    6: .standard(proto: "storage_list_request"),
    7: .standard(proto: "storage_list_response"),
    8: .standard(proto: "storage_read_request"),
    9: .standard(proto: "storage_read_response"),
    10: .standard(proto: "storage_write_request"),
    11: .standard(proto: "storage_delete_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.commandID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.commandStatus) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.notLast) }()
      case 4: try {
        var v: PBStatus_PingRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .pingRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .pingRequest(v)
        }
      }()
      case 5: try {
        var v: PBStatus_PingResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .pingResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .pingResponse(v)
        }
      }()
      case 6: try {
        var v: PBStorage_ListRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageListRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageListRequest(v)
        }
      }()
      case 7: try {
        var v: PBStorage_ListResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageListResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageListResponse(v)
        }
      }()
      case 8: try {
        var v: PBStorage_ReadRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageReadRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageReadRequest(v)
        }
      }()
      case 9: try {
        var v: PBStorage_ReadResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageReadResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageReadResponse(v)
        }
      }()
      case 10: try {
        var v: PBStorage_WriteRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageWriteRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageWriteRequest(v)
        }
      }()
      case 11: try {
        var v: PBStorage_DeleteRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageDeleteRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageDeleteRequest(v)
        }
      }()
      case 12: try {
        var v: PB_Dummy?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .dummy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .dummy(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.commandID, fieldNumber: 1)
    }
    if self.commandStatus != .ok {
      try visitor.visitSingularEnumField(value: self.commandStatus, fieldNumber: 2)
    }
    if self.notLast != false {
      try visitor.visitSingularBoolField(value: self.notLast, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .pingRequest?: try {
      guard case .pingRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .pingResponse?: try {
      guard case .pingResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .storageListRequest?: try {
      guard case .storageListRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .storageListResponse?: try {
      guard case .storageListResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .storageReadRequest?: try {
      guard case .storageReadRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .storageReadResponse?: try {
      guard case .storageReadResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .storageWriteRequest?: try {
      guard case .storageWriteRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .storageDeleteRequest?: try {
      guard case .storageDeleteRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .dummy?: try {
      guard case .dummy(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_Main, rhs: PB_Main) -> Bool {
    if lhs.commandID != rhs.commandID {return false}
    if lhs.commandStatus != rhs.commandStatus {return false}
    if lhs.notLast != rhs.notLast {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
