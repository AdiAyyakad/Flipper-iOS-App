// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: flipper.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PB_CommandStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ok // = 0

  ///*< Common Errors 
  case error // = 1

  ///*< Command can't be decoded successfully - command_id in response may be wrong! 
  case errorDecode // = 2

  ///*< Command succesfully decoded, but not implemented (deprecated or not yet implemented) 
  case errorNotImplemented // = 3

  ///*< Somebody took global lock, so not all commands are available 
  case errorBusy // = 4

  ///*< Not received has_next == 0 
  case errorContinuousCommandInterrupted // = 14

  ///*< not provided (or provided invalid) crucial parameters to perform rpc 
  case errorInvalidParameters // = 15

  ///*< Storage Errors 
  case errorStorageNotReady // = 5

  ///*< File/Dir alrady exist 
  case errorStorageExist // = 6

  ///*< File/Dir does not exist 
  case errorStorageNotExist // = 7

  ///*< Invalid API parameter 
  case errorStorageInvalidParameter // = 8

  ///*< Access denied 
  case errorStorageDenied // = 9

  ///*< Invalid name/path 
  case errorStorageInvalidName // = 10

  ///*< Internal error 
  case errorStorageInternal // = 11

  ///*< Functon not implemented 
  case errorStorageNotImplemented // = 12

  ///*< File/Dir already opened 
  case errorStorageAlreadyOpen // = 13

  ///*< Directory, you're going to remove is not empty 
  case errorStorageDirNotEmpty // = 18

  ///*< Application Errors 
  case errorAppCantStart // = 16

  ///*< Another app is running 
  case errorAppSystemLocked // = 17

  ///*< Virtual Display Errors 
  case errorVirtualDisplayAlreadyStarted // = 19

  ///*< Virtual Display session can't be stopped when it's not started 
  case errorVirtualDisplayNotStarted // = 20
  case UNRECOGNIZED(Int)

  init() {
    self = .ok
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .error
    case 2: self = .errorDecode
    case 3: self = .errorNotImplemented
    case 4: self = .errorBusy
    case 5: self = .errorStorageNotReady
    case 6: self = .errorStorageExist
    case 7: self = .errorStorageNotExist
    case 8: self = .errorStorageInvalidParameter
    case 9: self = .errorStorageDenied
    case 10: self = .errorStorageInvalidName
    case 11: self = .errorStorageInternal
    case 12: self = .errorStorageNotImplemented
    case 13: self = .errorStorageAlreadyOpen
    case 14: self = .errorContinuousCommandInterrupted
    case 15: self = .errorInvalidParameters
    case 16: self = .errorAppCantStart
    case 17: self = .errorAppSystemLocked
    case 18: self = .errorStorageDirNotEmpty
    case 19: self = .errorVirtualDisplayAlreadyStarted
    case 20: self = .errorVirtualDisplayNotStarted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ok: return 0
    case .error: return 1
    case .errorDecode: return 2
    case .errorNotImplemented: return 3
    case .errorBusy: return 4
    case .errorStorageNotReady: return 5
    case .errorStorageExist: return 6
    case .errorStorageNotExist: return 7
    case .errorStorageInvalidParameter: return 8
    case .errorStorageDenied: return 9
    case .errorStorageInvalidName: return 10
    case .errorStorageInternal: return 11
    case .errorStorageNotImplemented: return 12
    case .errorStorageAlreadyOpen: return 13
    case .errorContinuousCommandInterrupted: return 14
    case .errorInvalidParameters: return 15
    case .errorAppCantStart: return 16
    case .errorAppSystemLocked: return 17
    case .errorStorageDirNotEmpty: return 18
    case .errorVirtualDisplayAlreadyStarted: return 19
    case .errorVirtualDisplayNotStarted: return 20
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PB_CommandStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PB_CommandStatus] = [
    .ok,
    .error,
    .errorDecode,
    .errorNotImplemented,
    .errorBusy,
    .errorContinuousCommandInterrupted,
    .errorInvalidParameters,
    .errorStorageNotReady,
    .errorStorageExist,
    .errorStorageNotExist,
    .errorStorageInvalidParameter,
    .errorStorageDenied,
    .errorStorageInvalidName,
    .errorStorageInternal,
    .errorStorageNotImplemented,
    .errorStorageAlreadyOpen,
    .errorStorageDirNotEmpty,
    .errorAppCantStart,
    .errorAppSystemLocked,
    .errorVirtualDisplayAlreadyStarted,
    .errorVirtualDisplayNotStarted,
  ]
}

#endif  // swift(>=4.2)

/// There are Server commands (e.g. Storage_write), which have no body message
/// in response. But 'oneof' obligate to have at least 1 encoded message
/// in scope. For this needs Empty message is implemented.
struct PB_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PB_StopSession {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PB_Main {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var commandID: UInt32 = 0

  var commandStatus: PB_CommandStatus = .ok

  var hasNext_p: Bool = false

  var content: PB_Main.OneOf_Content? = nil

  var empty: PB_Empty {
    get {
      if case .empty(let v)? = content {return v}
      return PB_Empty()
    }
    set {content = .empty(newValue)}
  }

  var stopSession: PB_StopSession {
    get {
      if case .stopSession(let v)? = content {return v}
      return PB_StopSession()
    }
    set {content = .stopSession(newValue)}
  }

  var pingRequest: PBStatus_PingRequest {
    get {
      if case .pingRequest(let v)? = content {return v}
      return PBStatus_PingRequest()
    }
    set {content = .pingRequest(newValue)}
  }

  var pingResponse: PBStatus_PingResponse {
    get {
      if case .pingResponse(let v)? = content {return v}
      return PBStatus_PingResponse()
    }
    set {content = .pingResponse(newValue)}
  }

  var storageStatRequest: PBStorage_StatRequest {
    get {
      if case .storageStatRequest(let v)? = content {return v}
      return PBStorage_StatRequest()
    }
    set {content = .storageStatRequest(newValue)}
  }

  var storageStatResponse: PBStorage_StatResponse {
    get {
      if case .storageStatResponse(let v)? = content {return v}
      return PBStorage_StatResponse()
    }
    set {content = .storageStatResponse(newValue)}
  }

  var storageListRequest: PBStorage_ListRequest {
    get {
      if case .storageListRequest(let v)? = content {return v}
      return PBStorage_ListRequest()
    }
    set {content = .storageListRequest(newValue)}
  }

  var storageListResponse: PBStorage_ListResponse {
    get {
      if case .storageListResponse(let v)? = content {return v}
      return PBStorage_ListResponse()
    }
    set {content = .storageListResponse(newValue)}
  }

  var storageReadRequest: PBStorage_ReadRequest {
    get {
      if case .storageReadRequest(let v)? = content {return v}
      return PBStorage_ReadRequest()
    }
    set {content = .storageReadRequest(newValue)}
  }

  var storageReadResponse: PBStorage_ReadResponse {
    get {
      if case .storageReadResponse(let v)? = content {return v}
      return PBStorage_ReadResponse()
    }
    set {content = .storageReadResponse(newValue)}
  }

  var storageWriteRequest: PBStorage_WriteRequest {
    get {
      if case .storageWriteRequest(let v)? = content {return v}
      return PBStorage_WriteRequest()
    }
    set {content = .storageWriteRequest(newValue)}
  }

  var storageDeleteRequest: PBStorage_DeleteRequest {
    get {
      if case .storageDeleteRequest(let v)? = content {return v}
      return PBStorage_DeleteRequest()
    }
    set {content = .storageDeleteRequest(newValue)}
  }

  var storageMkdirRequest: PBStorage_MkdirRequest {
    get {
      if case .storageMkdirRequest(let v)? = content {return v}
      return PBStorage_MkdirRequest()
    }
    set {content = .storageMkdirRequest(newValue)}
  }

  var storageMd5SumRequest: PBStorage_Md5sumRequest {
    get {
      if case .storageMd5SumRequest(let v)? = content {return v}
      return PBStorage_Md5sumRequest()
    }
    set {content = .storageMd5SumRequest(newValue)}
  }

  var storageMd5SumResponse: PBStorage_Md5sumResponse {
    get {
      if case .storageMd5SumResponse(let v)? = content {return v}
      return PBStorage_Md5sumResponse()
    }
    set {content = .storageMd5SumResponse(newValue)}
  }

  var appStartRequest: PBApp_StartRequest {
    get {
      if case .appStartRequest(let v)? = content {return v}
      return PBApp_StartRequest()
    }
    set {content = .appStartRequest(newValue)}
  }

  var appLockStatusRequest: PBApp_LockStatusRequest {
    get {
      if case .appLockStatusRequest(let v)? = content {return v}
      return PBApp_LockStatusRequest()
    }
    set {content = .appLockStatusRequest(newValue)}
  }

  var appLockStatusResponse: PBApp_LockStatusResponse {
    get {
      if case .appLockStatusResponse(let v)? = content {return v}
      return PBApp_LockStatusResponse()
    }
    set {content = .appLockStatusResponse(newValue)}
  }

  var guiStartScreenStreamRequest: PBGui_StartScreenStreamRequest {
    get {
      if case .guiStartScreenStreamRequest(let v)? = content {return v}
      return PBGui_StartScreenStreamRequest()
    }
    set {content = .guiStartScreenStreamRequest(newValue)}
  }

  var guiStopScreenStreamRequest: PBGui_StopScreenStreamRequest {
    get {
      if case .guiStopScreenStreamRequest(let v)? = content {return v}
      return PBGui_StopScreenStreamRequest()
    }
    set {content = .guiStopScreenStreamRequest(newValue)}
  }

  var guiScreenFrame: PBGui_ScreenFrame {
    get {
      if case .guiScreenFrame(let v)? = content {return v}
      return PBGui_ScreenFrame()
    }
    set {content = .guiScreenFrame(newValue)}
  }

  var guiSendInputEventRequest: PBGui_SendInputEventRequest {
    get {
      if case .guiSendInputEventRequest(let v)? = content {return v}
      return PBGui_SendInputEventRequest()
    }
    set {content = .guiSendInputEventRequest(newValue)}
  }

  var guiStartVirtualDisplayRequest: PBGui_StartVirtualDisplayRequest {
    get {
      if case .guiStartVirtualDisplayRequest(let v)? = content {return v}
      return PBGui_StartVirtualDisplayRequest()
    }
    set {content = .guiStartVirtualDisplayRequest(newValue)}
  }

  var guiStopVirtualDisplayRequest: PBGui_StopVirtualDisplayRequest {
    get {
      if case .guiStopVirtualDisplayRequest(let v)? = content {return v}
      return PBGui_StopVirtualDisplayRequest()
    }
    set {content = .guiStopVirtualDisplayRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case empty(PB_Empty)
    case stopSession(PB_StopSession)
    case pingRequest(PBStatus_PingRequest)
    case pingResponse(PBStatus_PingResponse)
    case storageStatRequest(PBStorage_StatRequest)
    case storageStatResponse(PBStorage_StatResponse)
    case storageListRequest(PBStorage_ListRequest)
    case storageListResponse(PBStorage_ListResponse)
    case storageReadRequest(PBStorage_ReadRequest)
    case storageReadResponse(PBStorage_ReadResponse)
    case storageWriteRequest(PBStorage_WriteRequest)
    case storageDeleteRequest(PBStorage_DeleteRequest)
    case storageMkdirRequest(PBStorage_MkdirRequest)
    case storageMd5SumRequest(PBStorage_Md5sumRequest)
    case storageMd5SumResponse(PBStorage_Md5sumResponse)
    case appStartRequest(PBApp_StartRequest)
    case appLockStatusRequest(PBApp_LockStatusRequest)
    case appLockStatusResponse(PBApp_LockStatusResponse)
    case guiStartScreenStreamRequest(PBGui_StartScreenStreamRequest)
    case guiStopScreenStreamRequest(PBGui_StopScreenStreamRequest)
    case guiScreenFrame(PBGui_ScreenFrame)
    case guiSendInputEventRequest(PBGui_SendInputEventRequest)
    case guiStartVirtualDisplayRequest(PBGui_StartVirtualDisplayRequest)
    case guiStopVirtualDisplayRequest(PBGui_StopVirtualDisplayRequest)

  #if !swift(>=4.1)
    static func ==(lhs: PB_Main.OneOf_Content, rhs: PB_Main.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stopSession, .stopSession): return {
        guard case .stopSession(let l) = lhs, case .stopSession(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pingRequest, .pingRequest): return {
        guard case .pingRequest(let l) = lhs, case .pingRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pingResponse, .pingResponse): return {
        guard case .pingResponse(let l) = lhs, case .pingResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageStatRequest, .storageStatRequest): return {
        guard case .storageStatRequest(let l) = lhs, case .storageStatRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageStatResponse, .storageStatResponse): return {
        guard case .storageStatResponse(let l) = lhs, case .storageStatResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageListRequest, .storageListRequest): return {
        guard case .storageListRequest(let l) = lhs, case .storageListRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageListResponse, .storageListResponse): return {
        guard case .storageListResponse(let l) = lhs, case .storageListResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageReadRequest, .storageReadRequest): return {
        guard case .storageReadRequest(let l) = lhs, case .storageReadRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageReadResponse, .storageReadResponse): return {
        guard case .storageReadResponse(let l) = lhs, case .storageReadResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageWriteRequest, .storageWriteRequest): return {
        guard case .storageWriteRequest(let l) = lhs, case .storageWriteRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageDeleteRequest, .storageDeleteRequest): return {
        guard case .storageDeleteRequest(let l) = lhs, case .storageDeleteRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageMkdirRequest, .storageMkdirRequest): return {
        guard case .storageMkdirRequest(let l) = lhs, case .storageMkdirRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageMd5SumRequest, .storageMd5SumRequest): return {
        guard case .storageMd5SumRequest(let l) = lhs, case .storageMd5SumRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storageMd5SumResponse, .storageMd5SumResponse): return {
        guard case .storageMd5SumResponse(let l) = lhs, case .storageMd5SumResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appStartRequest, .appStartRequest): return {
        guard case .appStartRequest(let l) = lhs, case .appStartRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appLockStatusRequest, .appLockStatusRequest): return {
        guard case .appLockStatusRequest(let l) = lhs, case .appLockStatusRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appLockStatusResponse, .appLockStatusResponse): return {
        guard case .appLockStatusResponse(let l) = lhs, case .appLockStatusResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guiStartScreenStreamRequest, .guiStartScreenStreamRequest): return {
        guard case .guiStartScreenStreamRequest(let l) = lhs, case .guiStartScreenStreamRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guiStopScreenStreamRequest, .guiStopScreenStreamRequest): return {
        guard case .guiStopScreenStreamRequest(let l) = lhs, case .guiStopScreenStreamRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guiScreenFrame, .guiScreenFrame): return {
        guard case .guiScreenFrame(let l) = lhs, case .guiScreenFrame(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guiSendInputEventRequest, .guiSendInputEventRequest): return {
        guard case .guiSendInputEventRequest(let l) = lhs, case .guiSendInputEventRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guiStartVirtualDisplayRequest, .guiStartVirtualDisplayRequest): return {
        guard case .guiStartVirtualDisplayRequest(let l) = lhs, case .guiStartVirtualDisplayRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guiStopVirtualDisplayRequest, .guiStopVirtualDisplayRequest): return {
        guard case .guiStopVirtualDisplayRequest(let l) = lhs, case .guiStopVirtualDisplayRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "PB"

extension PB_CommandStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "ERROR"),
    2: .same(proto: "ERROR_DECODE"),
    3: .same(proto: "ERROR_NOT_IMPLEMENTED"),
    4: .same(proto: "ERROR_BUSY"),
    5: .same(proto: "ERROR_STORAGE_NOT_READY"),
    6: .same(proto: "ERROR_STORAGE_EXIST"),
    7: .same(proto: "ERROR_STORAGE_NOT_EXIST"),
    8: .same(proto: "ERROR_STORAGE_INVALID_PARAMETER"),
    9: .same(proto: "ERROR_STORAGE_DENIED"),
    10: .same(proto: "ERROR_STORAGE_INVALID_NAME"),
    11: .same(proto: "ERROR_STORAGE_INTERNAL"),
    12: .same(proto: "ERROR_STORAGE_NOT_IMPLEMENTED"),
    13: .same(proto: "ERROR_STORAGE_ALREADY_OPEN"),
    14: .same(proto: "ERROR_CONTINUOUS_COMMAND_INTERRUPTED"),
    15: .same(proto: "ERROR_INVALID_PARAMETERS"),
    16: .same(proto: "ERROR_APP_CANT_START"),
    17: .same(proto: "ERROR_APP_SYSTEM_LOCKED"),
    18: .same(proto: "ERROR_STORAGE_DIR_NOT_EMPTY"),
    19: .same(proto: "ERROR_VIRTUAL_DISPLAY_ALREADY_STARTED"),
    20: .same(proto: "ERROR_VIRTUAL_DISPLAY_NOT_STARTED"),
  ]
}

extension PB_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_Empty, rhs: PB_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_StopSession: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopSession"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_StopSession, rhs: PB_StopSession) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PB_Main: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Main"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    2: .standard(proto: "command_status"),
    3: .standard(proto: "has_next"),
    4: .same(proto: "empty"),
    19: .standard(proto: "stop_session"),
    5: .standard(proto: "ping_request"),
    6: .standard(proto: "ping_response"),
    24: .standard(proto: "storage_stat_request"),
    25: .standard(proto: "storage_stat_response"),
    7: .standard(proto: "storage_list_request"),
    8: .standard(proto: "storage_list_response"),
    9: .standard(proto: "storage_read_request"),
    10: .standard(proto: "storage_read_response"),
    11: .standard(proto: "storage_write_request"),
    12: .standard(proto: "storage_delete_request"),
    13: .standard(proto: "storage_mkdir_request"),
    14: .standard(proto: "storage_md5sum_request"),
    15: .standard(proto: "storage_md5sum_response"),
    16: .standard(proto: "app_start_request"),
    17: .standard(proto: "app_lock_status_request"),
    18: .standard(proto: "app_lock_status_response"),
    20: .standard(proto: "gui_start_screen_stream_request"),
    21: .standard(proto: "gui_stop_screen_stream_request"),
    22: .standard(proto: "gui_screen_frame"),
    23: .standard(proto: "gui_send_input_event_request"),
    26: .standard(proto: "gui_start_virtual_display_request"),
    27: .standard(proto: "gui_stop_virtual_display_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.commandID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.commandStatus) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hasNext_p) }()
      case 4: try {
        var v: PB_Empty?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .empty(v)
        }
      }()
      case 5: try {
        var v: PBStatus_PingRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .pingRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .pingRequest(v)
        }
      }()
      case 6: try {
        var v: PBStatus_PingResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .pingResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .pingResponse(v)
        }
      }()
      case 7: try {
        var v: PBStorage_ListRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageListRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageListRequest(v)
        }
      }()
      case 8: try {
        var v: PBStorage_ListResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageListResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageListResponse(v)
        }
      }()
      case 9: try {
        var v: PBStorage_ReadRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageReadRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageReadRequest(v)
        }
      }()
      case 10: try {
        var v: PBStorage_ReadResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageReadResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageReadResponse(v)
        }
      }()
      case 11: try {
        var v: PBStorage_WriteRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageWriteRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageWriteRequest(v)
        }
      }()
      case 12: try {
        var v: PBStorage_DeleteRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageDeleteRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageDeleteRequest(v)
        }
      }()
      case 13: try {
        var v: PBStorage_MkdirRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageMkdirRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageMkdirRequest(v)
        }
      }()
      case 14: try {
        var v: PBStorage_Md5sumRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageMd5SumRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageMd5SumRequest(v)
        }
      }()
      case 15: try {
        var v: PBStorage_Md5sumResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageMd5SumResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageMd5SumResponse(v)
        }
      }()
      case 16: try {
        var v: PBApp_StartRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appStartRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appStartRequest(v)
        }
      }()
      case 17: try {
        var v: PBApp_LockStatusRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appLockStatusRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appLockStatusRequest(v)
        }
      }()
      case 18: try {
        var v: PBApp_LockStatusResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .appLockStatusResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .appLockStatusResponse(v)
        }
      }()
      case 19: try {
        var v: PB_StopSession?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .stopSession(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .stopSession(v)
        }
      }()
      case 20: try {
        var v: PBGui_StartScreenStreamRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guiStartScreenStreamRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guiStartScreenStreamRequest(v)
        }
      }()
      case 21: try {
        var v: PBGui_StopScreenStreamRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guiStopScreenStreamRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guiStopScreenStreamRequest(v)
        }
      }()
      case 22: try {
        var v: PBGui_ScreenFrame?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guiScreenFrame(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guiScreenFrame(v)
        }
      }()
      case 23: try {
        var v: PBGui_SendInputEventRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guiSendInputEventRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guiSendInputEventRequest(v)
        }
      }()
      case 24: try {
        var v: PBStorage_StatRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageStatRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageStatRequest(v)
        }
      }()
      case 25: try {
        var v: PBStorage_StatResponse?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .storageStatResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .storageStatResponse(v)
        }
      }()
      case 26: try {
        var v: PBGui_StartVirtualDisplayRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guiStartVirtualDisplayRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guiStartVirtualDisplayRequest(v)
        }
      }()
      case 27: try {
        var v: PBGui_StopVirtualDisplayRequest?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .guiStopVirtualDisplayRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .guiStopVirtualDisplayRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.commandID != 0 {
      try visitor.visitSingularUInt32Field(value: self.commandID, fieldNumber: 1)
    }
    if self.commandStatus != .ok {
      try visitor.visitSingularEnumField(value: self.commandStatus, fieldNumber: 2)
    }
    if self.hasNext_p != false {
      try visitor.visitSingularBoolField(value: self.hasNext_p, fieldNumber: 3)
    }
    switch self.content {
    case .empty?: try {
      guard case .empty(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .pingRequest?: try {
      guard case .pingRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .pingResponse?: try {
      guard case .pingResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .storageListRequest?: try {
      guard case .storageListRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .storageListResponse?: try {
      guard case .storageListResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .storageReadRequest?: try {
      guard case .storageReadRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .storageReadResponse?: try {
      guard case .storageReadResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .storageWriteRequest?: try {
      guard case .storageWriteRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .storageDeleteRequest?: try {
      guard case .storageDeleteRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .storageMkdirRequest?: try {
      guard case .storageMkdirRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .storageMd5SumRequest?: try {
      guard case .storageMd5SumRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .storageMd5SumResponse?: try {
      guard case .storageMd5SumResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .appStartRequest?: try {
      guard case .appStartRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .appLockStatusRequest?: try {
      guard case .appLockStatusRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .appLockStatusResponse?: try {
      guard case .appLockStatusResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .stopSession?: try {
      guard case .stopSession(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .guiStartScreenStreamRequest?: try {
      guard case .guiStartScreenStreamRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .guiStopScreenStreamRequest?: try {
      guard case .guiStopScreenStreamRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .guiScreenFrame?: try {
      guard case .guiScreenFrame(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .guiSendInputEventRequest?: try {
      guard case .guiSendInputEventRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .storageStatRequest?: try {
      guard case .storageStatRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .storageStatResponse?: try {
      guard case .storageStatResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .guiStartVirtualDisplayRequest?: try {
      guard case .guiStartVirtualDisplayRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .guiStopVirtualDisplayRequest?: try {
      guard case .guiStopVirtualDisplayRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PB_Main, rhs: PB_Main) -> Bool {
    if lhs.commandID != rhs.commandID {return false}
    if lhs.commandStatus != rhs.commandStatus {return false}
    if lhs.hasNext_p != rhs.hasNext_p {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
